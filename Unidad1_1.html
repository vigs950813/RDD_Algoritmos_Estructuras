<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"></script>
    <title>Algoritmia</title>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --text-color: #333;
            --text-light: #7f8c8d;
        }

        body {
            font-family: 'Open Sans', sans-serif;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        .navbar-brand,
        .nav-link,
        .boton-disp {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
        }

        .navbar-personalizado {
            background-color: var(--primary-color);
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        * {
            text-align: justify;
        }

        p {
            text-align: justify;
        }

        .disposicion {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .disposicion-logos {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 20px;
            margin-bottom: 20px;
        }

        .disposicion-logos div {
            display: flex;
            align-items: center;
        }



        .navbar-brand {
            color: white !important;
            font-size: 1.5rem;
            margin-right: 30px;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8) !important;
            padding: 8px 15px !important;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            color: white !important;
            transform: translateY(-2px);
        }

        .dropdown-menu {
            border: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .dropdown-item {
            padding: 8px 20px;
            transition: all 0.2s;
        }

        .dropdown-item:hover {
            background-color: var(--secondary-color);
            color: white !important;
        }

        .container {
            max-width: 1200px;
            padding: 20px;
        }

        .presentacion {
            background-color: var(--secondary-color);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .presentacion:hover {
            transform: translateY(-5px);
        }

        .boton-disp {
            width: 100%;
            margin: 10px 0;
            padding: 15px 20px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: 1.1rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .boton-disp:hover {
            background-color: var(--dark-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .boton-disp i {
            transition: transform 0.3s ease;
        }

        .boton-disp.collapsed i {
            transform: rotate(-90deg);
        }

        #div_1,
        #div_2,
        #div_3,
        #div_4,
        #div_5 {
            padding: 25px;
            background-color: white;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--secondary-color);
        }

        footer {
            background-color: var(--primary-color);
            color: white;
            padding: 50px 0 0;
            margin-top: 50px;
        }

        footer h5 {
            color: white;
            margin-bottom: 20px;
            font-weight: 700;
        }

        footer .nav-link {
            color: rgba(255, 255, 255, 0.7) !important;
            padding: 5px 0 !important;
        }

        footer .nav-link:hover {
            color: white !important;
            padding-left: 10px !important;
        }

        .border-top {
            border-color: rgba(255, 255, 255, 0.1) !important;
        }

        .social-icons a {
            color: white;
            font-size: 1.5rem;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .social-icons a:hover {
            color: var(--secondary-color);
            transform: translateY(-3px);
        }

        .color-text {
            color: white;
        }

        .renglones {
            display: flex;
            flex-direction: column;
        }

        .margin-padding {
            margin: 0;
            padding: 0;
        }

        .centrar-imagen {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .centrar-imagen img {
            max-width: 600px;
            max-height: 600px;
        }

        @media (max-width: 768px) {
            .disposicion {
                flex-direction: column;
            }

            .navbar-brand {
                margin-bottom: 15px;
            }

            .presentacion {
                padding: 20px;
            }

            .centrar-imagen img {
                max-width: 400px;
                max-height: 400px;
            }

        }



        h1,
        h2,
        h3 {
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table,
        th,
        td {
            border: 1px solid #ddd;
        }

        th,
        td {
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        figure {
            margin: 20px 0;
            text-align: center;
        }

        figcaption {
            font-style: italic;
            margin-top: 10px;
        }

        .highlight {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #4285f4;
            margin: 20px 0;
        }

        .paginacion {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .btn-paginacion {
            padding: 10px 25px;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
        }

        .btn-paginacion:hover {
            background-color: #3498db;
            text-decoration: none;
        }

        .btn-paginacion:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            text-decoration: none;
        }
    </style>
</head>

<body>
    <div id="navbar-container"></div>


    <div class="container">
        <div class="presentacion" style="color: #f8f9fa;">
            <h2>1.1 Algoritmia</h2>
        </div>



        <p>La algoritmia, seg√∫n Cormen, Leiserson, Rivest y Stein (2022), se define como el estudio de los algoritmos,
           entendidos como una secuencia finita y l√≥gica de pasos destinados a resolver un problema o ejecutar una tarea.
           Su importancia radica en organizar procesos de manera ordenada, optimizar recursos y constituir la base para
           el dise√±o de programas y sistemas inform√°ticos.</p>

        <h4>Caracter√≠sticas de la algoritmia</h4>

        <p>a) Secuencialidad: los pasos deben seguir un orden l√≥gico y definido.</p>
        <p>b) Finitud: todo algoritmo debe terminar despu√©s de un n√∫mero limitado de pasos.</p>
        <p>c) Precisi√≥n: cada instrucci√≥n debe estar claramente definida, sin ambig√ºedades.</p>
        <p>d) Entrada y salida: requiere datos de entrada y produce resultados o salidas.</p>
        <p>e) Eficiencia: busca optimizar recursos como tiempo y memoria.</p>
        <p>f) Generalidad: un mismo algoritmo puede aplicarse a diferentes problemas con condiciones similares.</p>

           Seg√∫n Cormen, Leiserson, Rivest y Stein (2022), estas propiedades aseguran que los algoritmos sean correctos,
           comprensibles y aplicables en la resoluci√≥n de problemas computacionales..</p>

        <h4>Importancia de la algoritmia en la estructura de datos</h4>

        <p>La algoritmia, de acuerdo con Cormen, Leiserson, Rivest y Stein (2022), es fundamental en el estudio y aplicaci√≥n
           de las estructuras de datos, ya que posibilita el dise√±o de procedimientos eficientes para almacenar, organizar y
           manipular la informaci√≥n. Su relevancia radica en que ofrece m√©todos para seleccionar el algoritmo m√°s adecuado
           en funci√≥n de la complejidad temporal y espacial, asegurando soluciones √≥ptimas en el procesamiento de datos.
           En este sentido, la integraci√≥n de algoritmos y estructuras de datos constituye la base para el desarrollo
           de software eficiente, seguro y escalable.</p>

        <h4>Caracter√≠sticas de la algoritmia con base en sus √≥rdenes de complejidad</h4>
        <ol>
            <li><strong>Medici√≥n del rendimiento:</strong> la algoritmia permite evaluar el desempe√±o de los algoritmos
                mediante funciones de complejidad que expresan el tiempo o recursos necesarios en relaci√≥n
                con el tama√±o de la entrada.</li>
            <li><strong>Clasificaci√≥n de algoritmos:</strong> a trav√©s de la notaci√≥n Big-O, se pueden agrupar algoritmos en 
                categor√≠as como constantes (O(1)), lineales (O(n)), logar√≠tmicos (O(log n)) o cuadr√°ticos (O(n¬≤)), 
                lo que facilita su comparaci√≥n.</li>
            <li><strong>Eficiencia y optimizaci√≥n:</strong> el an√°lisis de complejidad orienta la selecci√≥n del algoritmo
                m√°s adecuado para reducir el consumo de tiempo y memoria en la resoluci√≥n de problemas.</li>
            <li><strong>Escalabilidad:</strong> permite prever c√≥mo crecer√° el costo computacional a medida que aumente el
                tama√±o de los datos de entrada, asegurando que las soluciones sean viables en escenarios de gran escala.</li>
            <li><strong>Base para la toma de decisiones:</strong> el estudio de la complejidad proporciona criterios objetivos
                para elegir algoritmos, considerando no s√≥lo la correcci√≥n, sino tambi√©n la eficiencia en contextos reales.</li>
                  
        </ol>
        <p> De acuerdo con Cormen, Leiserson, Rivest y Stein (2022), analizar los algoritmos bajo el enfoque de la 
            complejidad temporal y espacial es esencial para garantizar soluciones computacionales eficientes, 
            seguras y escalables.</p>
        <div class="highlight">
            <h4>Resumen algoritmia </h4>
            <ul>
                <li>Medici√≥n del rendimiento: eval√∫a el tiempo y recursos que consume un algoritmo.</li>
                <li>Clasificaci√≥n de algoritmos: utiliza notaci√≥n Big-O (O(1), O(n), O(log n), O(n¬≤)) para agruparlos seg√∫n su eficiencia</li>
                <li>Eficiencia y optimizaci√≥n: ayuda a elegir el algoritmo que mejor aproveche tiempo y memoria.</li>
                <li>Escalabilidad: permite prever c√≥mo crece el costo computacional al aumentar los datos de entrada.</li>
                <li>Base para la toma de decisiones: ofrece criterios objetivos para seleccionar algoritmos en la resoluci√≥n de problemas reales.</li>
                
            </ul>
            <p>De acuerdo con Cormen, Leiserson, Rivest y Stein (2022), estas caracter√≠sticas hacen de la algoritmia un elemento
               esencial para el desarrollo de software eficiente, seguro y escalable..
            </p>
        </div>
        <p>La siguiente figura muestra c√≥mo los algoritmos a trav√©s de √≥rdenes complejas interact√∫an con las bases de datos para generar
           resultados eficientes. Resalta la importancia de la complejidad algor√≠tmica en la optimizaci√≥n del procesamiento y la
           gesti√≥n de la informaci√≥n en sistemas computacionales.</p>
        <br>
        <figure>
            <span>Fig. 1. Algoritmia y el impacto en la programaci√≥n con √≥rdenes complejas y bases de datos. La imagen representa la
                  interacci√≥n entre algoritmos y bases de datos, destacando c√≥mo la complejidad algor√≠tmica influye en la eficiencia
                  del procesamiento y la obtenci√≥n de resultados en sistemas computacionales.</span>
        </figure>
        <div class="centrar-imagen">
            <img src="images/figura1.png" alt="figura_1" style="max-width: 600px; max-height: 600px;">
        </div>
        <br>

            
        <h4>1.1.1 Caracter√≠sticas de los algoritmos y tipos</h4>

        <p>Seg√∫n Cormen, Leiserson, Rivest y Stein (2022), los algoritmos constituyen procedimientos sistem√°ticos que permiten
           resolver problemas a trav√©s de una secuencia de pasos bien definidos. Una de sus caracter√≠sticas esenciales es la finitud,
           ya que todo algoritmo debe concluir despu√©s de un n√∫mero limitado de instrucciones; de lo contrario, se tratar√≠a de un proceso
           infinito sin aplicaci√≥n pr√°ctica. Adem√°s, la precisi√≥n es fundamental, pues cada paso debe estar claramente formulado y libre
           de ambig√ºedades, garantizando que tanto personas como m√°quinas lo ejecuten de forma id√©ntica. Asimismo, un algoritmo requiere
           siempre datos de entrada, que funcionan como base para su ejecuci√≥n, y debe ofrecer al menos una salida, que constituye el
           resultado final del procedimiento. Estas propiedades aseguran que el proceso sea verificable, trazable y confiable en
           cualquier contexto computacional.

        <p>Seg√∫n Cormen, Leiserson, Rivest y Stein (2022), otro aspecto clave es la efectividad, entendida como la posibilidad
           de que cada instrucci√≥n pueda llevarse a cabo en un tiempo finito y con recursos razonables, lo cual garantiza la viabilidad
           de su aplicaci√≥n. Adem√°s, los algoritmos deben mantener un orden l√≥gico en la secuencia de pasos, de modo que la soluci√≥n del
           problema se alcance de manera coherente y eficiente. En conjunto, estas caracter√≠sticas permiten dise√±ar procedimientos que no
           s√≥lo resuelvan un problema, sino que lo hagan optimizando el uso de tiempo y memoria, lo cual es fundamental en la 
           programaci√≥n y en el manejo de grandes vol√∫menes de datos.</p>

        <h4>Tipos de algoritmos </h4>

        <p>Seg√∫n Brassard y Bratley (1996), los algoritmos pueden clasificarse en distintos tipos seg√∫n la forma en que estructuran y
           procesan la informaci√≥n. Los secuenciales siguen un flujo lineal de pasos que se ejecutan uno tras otro, mientras que los
           condicionales incorporan decisiones l√≥gicas que permiten elegir diferentes rutas de ejecuci√≥n. Los iterativos repiten bloques
           de instrucciones hasta que se cumple una condici√≥n de salida, y los recursivos se llaman a s√≠ mismos para resolver subproblemas
           que forman parte del problema original.</p>

        <p>Seg√∫n Brassard y Bratley (1996), tambi√©n se distinguen algoritmos deterministas, que producen siempre la misma salida para una
           entrada espec√≠fica, y algoritmos no deterministas o probabil√≠sticos, que integran componentes aleatorios para explorar soluciones
           en problemas de gran complejidad. Asimismo, en la actualidad adquieren gran relevancia los algoritmos paralelos y concurrentes, 
           que dividen una tarea en m√∫ltiples subprocesos ejecutados de manera simult√°nea, lo que permite aprovechar mejor los recursos 
           computacionales y reducir considerablemente los tiempos de procesamiento en sistemas de gran escala.</p>

        

        <h4>Seg√∫n Brassard y Bratley (1996), los algoritmos pueden clasificarse en diferentes tipos como en su estructura y
            modo de resoluci√≥n:</h4>
        
        <p>a) Algoritmos secuenciales: siguen un flujo lineal de instrucciones, donde cada paso se ejecuta en un orden estricto
           hasta llegar al resultado final. Son los m√°s sencillos y se utilizan en problemas directos sin necesidad de decisiones complejas.

        <p>b) Algoritmos condicionales: incorporan estructuras de decisi√≥n (si‚Äìentonces‚Äìde lo contrario), que permiten elegir entre
           varias rutas de ejecuci√≥n dependiendo de las condiciones establecidas. Son fundamentales en la programaci√≥n moderna, ya que
           introducen flexibilidad y adaptabilidad.

        <p>c) Algoritmos iterativos: se basan en la repetici√≥n de bloques de instrucciones mediante ciclos o bucles, los cuales se repiten
           hasta que se cumpla una condici√≥n de terminaci√≥n. Son √∫tiles en procesos repetitivos como c√°lculos matem√°ticos o recorridos de estructuras de datos.

        <p>d) Algoritmos recursivos: se caracterizan por invocarse a s√≠ mismos, resolviendo subproblemas m√°s peque√±os del problema original. Este tipo de
           dise√±o permite simplificar problemas complejos como el c√°lculo de factoriales, recorridos de √°rboles o algoritmos de b√∫squeda y ordenamiento.

        <p>e) Algoritmos deterministas: garantizan siempre el mismo resultado para una entrada dada, ya que sus pasos est√°n perfectamente definidos y no
           incluyen elementos aleatorios. Esto asegura predictibilidad y confiabilidad en su ejecuci√≥n.

        <p>f) Algoritmos probabil√≠sticos o no deterministas: incluyen factores aleatorios en su ejecuci√≥n, lo que los hace especialmente √∫tiles en contextos
           donde la b√∫squeda de soluciones requiere explorar m√∫ltiples posibilidades, como en simulaciones, criptograf√≠a o inteligencia artificial.

         <p>g) Algoritmos paralelos y concurrentes: dividen un problema en subprocesos que pueden ejecutarse simult√°neamente en distintos procesadores o hilos,
           optimizando el tiempo de ejecuci√≥n y aprovechando mejor los recursos computacionales. Son esenciales en la era actual del c√≥mputo distribuido y 
           de alto rendimiento.
        </p>
        <p>  En s√≠ntesis, la clasificaci√≥n de los algoritmos no s√≥lo refleja su estructura l√≥gica, sino tambi√©n las necesidades de eficiencia, precisi√≥n y 
          escalabilidad en distintos contextos de aplicaci√≥n. 
        </p>

        <h4></h4>

        <p>La algoritmia aplicada a bases de datos permite dise√±ar procedimientos que optimicen la b√∫squeda, almacenamiento y
        recuperaci√≥n de informaci√≥n (Cormen et al., 2022). Un ejemplo es el algoritmo de b√∫squeda de un cliente por su identificador:
        si la tabla est√° indexada, el Sistema de Gesti√≥n de Bases de Datos usa estructuras como √°rboles B o hashing, logrando b√∫squedas
        en O(log n) u O(1); si no hay √≠ndices, recurre a una exploraci√≥n secuencial en O(n) (Silberschatz et al., 2020). Tras localizar
        el registro, se recupera la informaci√≥n y se cierra la conexi√≥n. La elecci√≥n del algoritmo e infraestructura de datos es cr√≠tica
        en grandes vol√∫menes, pues determina tiempos de respuesta y uso de recursos.</p>
        <br>
        <figure>

            <span>Figura 2. Caracter√≠sticas y tipos de algoritmos, adaptado de Cormen, Leiserson, Rivest y Stein, 2022.</span>
        </figure>
        <div class="centrar-imagen">
            <img src="images/figura22.png" alt="figura_2" style="max-width: 600px; max-height: 600px;">
        </div>
        <br>

        <h4>1.1.2 Representaci√≥n de algoritmos en pseudoc√≥digo</h4>

        <p>El pseudoc√≥digo es una forma de representaci√≥n intermedia entre el lenguaje natural y los lenguajes de programaci√≥n formales.
         Su prop√≥sito es expresar los pasos de un algoritmo de manera clara, estructurada y comprensible, sin depender de la sintaxis
         estricta de un lenguaje de programaci√≥n espec√≠fico. Esto facilita la comprensi√≥n del procedimiento l√≥gico tanto a programadores
         como a personas con conocimientos b√°sicos en inform√°tica.</p>

         <p>A diferencia de un lenguaje de programaci√≥n, el pseudoc√≥digo no se ejecuta en una computadora; sin embargo, sirve como
         gu√≠a para implementar el algoritmo posteriormente en cualquier lenguaje de programaci√≥n. Su principal ventaja es la abstracci√≥n,
         ya que permite centrarse en la l√≥gica y la secuencia de instrucciones sin distraerse con detalles t√©cnicos de la codificaci√≥n (Sierra y Rojas, 2020).</p>

        <h4>Formas de representar algoritmos</h4>

        <p>La representaci√≥n de un algoritmo tiene como objetivo describir una secuencia de instrucciones clara y comprensible para que cualquier persona
        pueda interpretarlo y ejecutarlo. Existen diversas maneras de expresar un algoritmo y cada una ofrece una perspectiva distinta que facilita su
        comprensi√≥n seg√∫n el contexto y el prop√≥sito (Garc√≠a y Joyanes, 2017).</p>

        <p></p>
        <ul>
            <li>1. Descripci√≥n textual: la representaci√≥n de un algoritmo consiste en la descripci√≥n ordenada de pasos que permiten resolver un problema
                de forma clara y precisa. Su finalidad es que cualquier persona, independientemente de su nivel de conocimiento t√©cnico, pueda interpretar y
                ejecutar las instrucciones sin ambig√ºedad. Para ello, se utilizan diversos lenguajes de representaci√≥n, como diagramas de flujo, pseudoc√≥digo o 
                incluso lenguajes de programaci√≥n, los cuales brindan distintas perspectivas que facilitan la comprensi√≥n del procedimiento seg√∫n el prop√≥sito y
                el contexto en el que se empleen y</li>
            <li>2. Estructura interna: los diagramas de Nassi-Shneiderman, tambi√©n conocidos como diagramas de estructuras, son una herramienta gr√°fica utilizada
                para representar algoritmos de manera jer√°rquica y estructurada. Su caracter√≠stica principal es que muestran el flujo de control a trav√©s de bloques
                rectangulares anidados, lo que facilita la comprensi√≥n de estructuras secuenciales, condicionales e iterativas. A diferencia de los diagramas de
                flujo tradicionales, los diagramas de Nassi-Shneiderman evitan el uso de flechas y s√≠mbolos adicionales, centr√°ndose en la claridad y en el dise√±o
                estructurado de programas. Gracias a esta representaci√≥n visual, se promueve una programaci√≥n m√°s ordenada, coherente y 
                libre de ambig√ºedades.</li><p></p>

           <p>La siguiente figura 3  Diagrama de Nassi-Shneiderman, muestra una representaci√≥n estructurada de un algoritmo mediante bloques rectangulares anidados.
              En la parte superior se observa el inicio y un proceso secuencial; posteriormente, se incluye una estructura condicional s√≠/no finalmente y un ciclo
              mientras que eval√∫a una condici√≥n y repite un proceso. Este tipo de diagramas facilita la comprensi√≥n de algoritmos al evitar el uso de flechas, promoviendo
              una visi√≥n clara y ordenada del flujo l√≥gico.</p>
        <figure>
           <span>Figura 3, Diagrama de Nassi-Shneiderman. adaptado de Fundamentos de Programaci√≥n: Algoritmos, estructuras de datos y objetos de Joyanes Aguilar (2008).</span>
        </figure>
        <div class="centrar-imagen">
            <img src="images/figura3.png" alt="Figura_3" style="max-width: 600px; max-height: 600px;">
        </div>
        <br>
            
            </li>
            <li>4. Diagramas de flujo: Los diagramas de flujo representan el flujo de un algoritmo utilizando figuras geom√©tricas que corresponden
                a distintos tipos de instrucciones, como inicio, proceso, decisi√≥n y fin. Esta representaci√≥n facilita la visualizaci√≥n del camino
                que sigue el algoritmo desde el inicio hasta su conclusi√≥n y es √∫til en el an√°lisis de algoritmos con m√∫ltiples caminos
                posibles.<p></p>

                El diagrama de flujo constituye una herramienta gr√°fica que permite representar de manera secuencial el recorrido de un algoritmo
                a trav√©s de s√≠mbolos estandarizados. En este caso, se observa el inicio mediante un √≥valo, seguido de un proceso representado por
                un rect√°ngulo. Posteriormente, se incluye una condici√≥n en forma de rombo que plantea una decisi√≥n con dos alternativas (s√≠ y no),
                las cuales conducen a diferentes caminos dentro de la l√≥gica del algoritmo. Finalmente, ambos caminos confluyen hacia un proceso 
                que culmina con el √≥valo de fin.<p></p>
            </li>
            <figure>
               <span>Figura 4, Diagramas de flujo. Esta representaci√≥n resulta particularmente √∫til en el an√°lisis de algoritmos que contemplan m√∫ltiples
               trayectorias, ya que posibilita una comprensi√≥n clara y estructurada del flujo l√≥gico de ejecuci√≥n.</span>
            </figure>
        <div class="centrar-imagen">
            <img src="images/figura5.png" alt="Figura_5" style="max-width: 600px; max-height: 600px;">
        </div>
       <p></p>
            <li>5. El pseudoc√≥digo: es una forma de representaci√≥n intermedia entre el lenguaje natural y un lenguaje de programaci√≥n. Su principal
                objetivo es describir de manera clara y estructurada los pasos de un algoritmo sin depender de la sintaxis estricta de un lenguaje espec√≠fico.
                De esta manera, facilita tanto el dise√±o de soluciones como la comunicaci√≥n de ideas entre programadores y personas con menor experiencia
                t√©cnica.<p></p>

                Una de sus ventajas radica en que combina expresiones en lenguaje com√∫n con estructuras propias de la programaci√≥n, como condicionales,
                bucles y secuencias. Esto permite representar algoritmos de forma precisa y entendible, sirviendo como etapa previa a la codificaci√≥n en
                un lenguaje formal.<p></p>
            </li>
            <span>C√≥digo 1, este pseudoc√≥digo describe de manera sencilla la l√≥gica necesaria para identificar si un n√∫mero es par o impar.
                Al emplear estructuras condicionales claras, se facilita la comprensi√≥n del procedimiento y su posterior traducci√≥n a un lenguaje de
                programaci√≥n. Elaboraci√≥n propia con base en Garc√≠a y Joyanes (2017). </span>

        <figure>
            <span>C√≥digo 1. Ejemplo de pseudoc√≥digo para determinar si un n√∫mero es par o impar.</span>
        </figure>

        <div class="centrar-imagen">
            <img src="images/Codigo_1.jpeg" alt="Codigo_1" style="max-width: 400px; max-height: 400px;">
        </div>
        <br />
    </ul>
     <div class="highlight">
            <h4>Resumen. La representaci√≥n de algoritmos es esencial para expresar de manera clara los pasos de una soluci√≥n:</h4>
            <ul>
                <li>La representaci√≥n de algoritmos es fundamental para describir de forma clara y ordenada los pasos de una
                    soluci√≥n, permitiendo su comprensi√≥n y ejecuci√≥n sin ambig√ºedades (Cormen, Leiserson, Rivest y Stein, 2022). Entre los
                    m√©todos m√°s utilizados destacan los diagramas de flujo, que emplean s√≠mbolos geom√©tricos para visualizar procesos y decisiones,
                    √∫tiles en algoritmos con m√∫ltiples trayectorias.</li>
                <li>Asimismo, los diagramas de Nassi-Shneiderman presentan estructuras jer√°rquicas mediante bloques rectangulares anidados, promoviendo
                    claridad y programaci√≥n estructurada (Joyanes Aguilar, 2008). Por √∫ltimo, el pseudoc√≥digo combina lenguaje natural con estructuras
                   de programaci√≥n, facilitando el dise√±o y la comunicaci√≥n de algoritmos antes de su codificaci√≥n. Clasificaci√≥n
                   de algoritmos: utiliza notaci√≥n Big-O (O(1), O(n), O(log n), O(n¬≤)) para agruparlos seg√∫n su eficiencia</li>
                <li>En conjunto, estas representaciones constituyen recursos pedag√≥gicos y pr√°cticos que fortalecen la ense√±anza y el an√°lisis de algoritmos.</li>
                                
            </ul>
            <p>Estas caracter√≠sticas hacen de la algoritmia un elemento
               esencial para el desarrollo de software eficiente, seguro y escalable.
            </p>
        </div>   
               
        <br>
        
<h4>1.1.3 Abstracci√≥n y tipo de dato abstracto</h4>
        
        <p>La abstracci√≥n en ciencias de la computaci√≥n consiste en identificar las caracter√≠sticas esenciales de un objeto o problema y 
           omitir los detalles irrelevantes para su an√°lisis o resoluci√≥n. Este principio permite simplificar sistemas complejos al
           centrarse en los aspectos m√°s relevantes para el dise√±o de soluciones, facilitando la comprensi√≥n, la organizaci√≥n de datos y
           la programaci√≥n estructurada.</p>

        <ol>
            <li><strong>Tipo de Dato Abstracto (TDA):</strong>
                <p>Un tipo de dato abstracto (TDA) es un modelo matem√°tico y l√≥gico que define un conjunto de datos y las operaciones
                   permitidas sobre ellos, sin especificar c√≥mo se implementan internamente. Los TDA, como pilas, colas, listas o √°rboles,
                   proporcionan una interfaz clara para el usuario, mientras que los detalles de implementaci√≥n permanecen ocultos.
                   Esto asegura independencia entre el uso y la programaci√≥n interna, lo que promueve modularidad y reutilizaci√≥n en
                   el desarrollo de software.</p>
            </li>
           
        </ol>

        <div class="highlight">
            <p>En resumen, La abstracci√≥n simplifica problemas al resaltar lo esencial y ocultar lo irrelevante (Joyanes Aguilar, 2008).
               Los tipos de datos abstractos (TDA) definen estructuras y operaciones sin detallar su implementaci√≥n, promoviendo modularidad y
               reutilizaci√≥n. Ambos son claves para dise√±ar sistemas eficientes y escalables.</p>
        </div>

        <h4>Abstracci√≥n en el desarrollo de software</h4>

        <p>En el desarrollo de software, la abstracci√≥n implica dividir un problema en componentes fundamentales y considerar
           tres elementos clave para su resoluci√≥n:</p>

        <h4>Datos de entrada</h4>

        <p>Corresponden a la informaci√≥n necesaria para resolver el problema. Estos datos pueden ser homog√©neos (del mismo tipo) o heterog√©neos
           (de distintos tipos) y representan los valores iniciales requeridos para el procesamiento.</p>

        <h4>Procesamiento</h4>

        <p>Es el conjunto de operaciones aplicadas sobre los datos de entrada mediante algoritmos, los cuales siguen reglas
           espec√≠ficas del paradigma de programaci√≥n empleado. Dichos algoritmos transforman la informaci√≥n para producir soluciones
           parciales o completas al problema.</p>

        <h4>Datos de salida</h4>

        <p>Son los resultados obtenidos tras el procesamiento, que pueden integrarse para ofrecer una soluci√≥n final al problema planteado (Gonz√°lez y Zapata, 2016).</p>

        <p>La abstracci√≥n permite adem√°s modelar los datos en diversas estructuras, que abarcan desde variables simples, arreglos y cadenas, hasta estructuras m√°s
          complejas como los structs, lo que facilita la organizaci√≥n y el procesamiento eficiente de la informaci√≥n.</p>
        
        <figure>
            <span>C√≥digo 2. Ejemplo para determinar si un n√∫mero es par o impar aplicando el principio de abstracci√≥n.</span>
        </figure>

       <div class="centrar-imagen">
            <img src="images/Codigo_22.jpeg" alt="Codigo_22" style="max-width: 400px; max-height: 400px;">
        </div>
        <br />


        <p>El programa ejemplifica el principio de abstracci√≥n al dividir el problema en entrada, procesamiento y salida. En la entrada,
           el usuario proporciona un n√∫mero entero; en el procesamiento, se aplica el operador m√≥dulo (%) para verificar si es divisible entre
           dos; y en la salida, el sistema muestra si el n√∫mero es par o impar.</p>
         <p>Este enfoque evidencia c√≥mo la abstracci√≥n facilita la organizaci√≥n del algoritmo y la comprensi√≥n del c√≥digo. Al separar cada etapa,
            se mejora la claridad, la mantenibilidad y la posibilidad de reutilizaci√≥n, aspectos considerados esenciales en el dise√±o y ense√±anza
            de programas inform√°ticos.</p>  



 <div class="highlight">
            <h4>Resumen del principio de abstracci√≥n en programaci√≥n. </h4>
            <ul>
                <li>La abstracci√≥n en programaci√≥n se entiende como el proceso de simplificar un problema al dividirlo en tres componentes esenciales: entrada,
                    procesamiento y salida. Este enfoque permite organizar de manera clara la l√≥gica de los algoritmos y facilita su comprensi√≥n tanto en la
                    ense√±anza como en la pr√°ctica del desarrollo de software.</li>
                <li>El ejemplo en c√≥digo C presentado muestra c√≥mo se aplican estos tres elementos: el usuario proporciona un n√∫mero entero como entrada,
                    el algoritmo aplica una operaci√≥n aritm√©tica como procesamiento y finalmente se genera un resultado que indica si el n√∫mero es par o impar
                    como salida.</li>
                                
            </ul>
            <p>Este m√©todo no solo ayuda a comprender la estructura de un programa, sino que tambi√©n fomenta la modularidad y la reutilizaci√≥n de c√≥digo,
               aspectos clave en la construcci√≥n de sistemas eficientes y escalables.
            </p>
        </div>   
               

<h4>1.1.4 Orden de complejidad ùëÇ() de un algoritmo</h4>
        
        <p>La abstracci√≥n en ciencias de la computaci√≥n consiste en identificar las caracter√≠sticas esenciales de un objeto o problema y 
           omitir los detalles irrelevantes para su an√°lisis o resoluci√≥n. Este principio permite simplificar sistemas complejos al
           centrarse en los aspectos m√°s relevantes para el dise√±o de soluciones, facilitando la comprensi√≥n, la organizaci√≥n de datos y
           la programaci√≥n estructurada.</p>

        <ol>
            <li><strong>Complejidad algor√≠tmica:</strong>
                <p>El an√°lisis de la complejidad algor√≠tmica busca determinar la eficiencia de un algoritmo en t√©rminos de los
                   recursos que emplea, principalmente el tiempo de ejecuci√≥n y el espacio en memoria. La notaci√≥n O() (Big O) describe
                   el comportamiento asint√≥tico de un algoritmo, es decir, c√≥mo var√≠a su rendimiento a medida que aumenta el tama√±o de
                   los datos de entrada (Cormen, Leiserson, Rivest y Stein, 2022). Esta medida permite comparar y diferentes algoritmos 
                   que resuelven un mismo problema, no s√≥lo por su correcci√≥n y sino tambi√©n por su eficiencia.</p>
            <li><strong>Tipos de complejidad temporal</strong>
                <p>La complejidad temporal se clasifica en varios √≥rdenes de crecimiento, cada uno con caracter√≠sticas particulares:</p>

           
                <p>a) Algoritmos secuenciales: siguen un flujo lineal de instrucciones, donde cada paso se ejecuta en un orden estricto
                      hasta llegar al resultado final. Son los m√°s sencillos y se utilizan en problemas directos sin necesidad de decisiones
                      complejas.</p>

        <p>b) O(1):<em>Constante.</em> <i></i> El tiempo de ejecuci√≥n no depende del tama√±o de la entrada. Ejemplo: acceder a un elemento en un arreglo.</p>


        <p>c) O(log n): <em>Logar√≠tmica. </em> <i></i> El tiempo crece lentamente conforme aumenta la entrada. Ejemplo: b√∫squeda binaria.</p>


        <p>d) O(n): <em>Lineal.</em>  <i></i> El tiempo crece de manera proporcional al tama√±o de la entrada. Ejemplo: recorrido de una lista.</p>

        <p>e) O(n log n): <em>Casi lineal.</em> <i></i> Propia de algoritmos eficientes de ordenamiento, como mergesort o quicksort.</p>

        <p>f) O(n¬≤): <em>Cuadr√°tica.</em> <i></i> El tiempo crece de forma cuadr√°tica respecto al tama√±o de la entrada. Ejemplo: ordenamiento por burbuja.</p>

         <p>g) O(2‚Åø) y O(n!). Complejidades exponenciales y factoriales, asociadas a problemas combinatorios que son inviables en escala (Garc√≠a y Joyanes, 2017) y
        </p>
               <li><strong>Complejidad espacial:</strong>
                <p>Adem√°s del tiempo, es relevante analizar el uso de memoria. La complejidad espacial mide el espacio adicional requerido 
                   por un algoritmo durante su ejecuci√≥n, considerando variables, estructuras de datos auxiliares y recursividad. Un algoritmo
                   eficiente busca optimizar tanto el tiempo como la memoria utilizada, equilibrando estos recursos seg√∫n el problema a
                   resolver.</p>
               <li><strong>Importancia del an√°lisis de complejidad:</strong>
                <p>El estudio de la complejidad no se limita a la teor√≠a; constituye un criterio pr√°ctico en el dise√±o y la selecci√≥n de algoritmos.
                   Como se√±alan Cormen et al. (2022), la eficiencia algor√≠tmica determina la viabilidad de un programa al procesar grandes vol√∫menes
                   de datos. En el √°mbito acad√©mico, su ense√±anza fomenta una visi√≥n cr√≠tica y anal√≠tica en los estudiantes, orient√°ndolos a dise√±ar
                   soluciones no s√≥lo funcionales, sino tambi√©n escalables y sostenibles.</p>

              </li>
           
        </ol>



        <p><strong>¬øPor qu√© es importante el problema de ordenamiento?</strong></p>
    </div>

    <div class="paginacion">
        <a href="Cuestionario1_1.html" class="btn-paginacion">Siguiente</a>
    </div>

    <div id="footer-container"></div>


    <script>
        $(document).ready(function () {
            fetch('navbar.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('navbar-container').innerHTML = data;
                    initNavbarScripts(); // Si necesitas inicializar scripts del navbar
                });

            fetch('footer.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('footer-container').innerHTML = data;
                });
        });
    </script>


</body>

</html>