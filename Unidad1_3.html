<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Métodos de Asignación de Espacio</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Open+Sans:wght@400;600&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
        integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --light-color: #ecf0f1;
            --dark-color: #2c3e50;
            --text-color: #333;
            --text-light: #7f8c8d;
        }

        body {
            font-family: 'Open Sans', sans-serif;
            color: var(--text-color);
            line-height: 1.6;
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        .navbar-brand,
        .nav-link,
        .boton-disp {
            font-family: 'Montserrat', sans-serif;
            font-weight: 600;
        }

        .navbar-personalizado {
            background-color: var(--primary-color);
            padding: 15px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .disposicion {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
        }

        * {
            text-align: justify;
        }

        p {
            text-align: justify;
        }

        .disposicion-logos {
            display: flex;
            justify-content: space-between;
            width: 100%;
            padding: 0 20px;
            margin-bottom: 20px;
        }

        .disposicion-logos div {
            display: flex;
            align-items: center;
        }



        .navbar-brand {
            color: white !important;
            font-size: 1.5rem;
            margin-right: 30px;
        }

        .nav-link {
            color: rgba(255, 255, 255, 0.8) !important;
            padding: 8px 15px !important;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            color: white !important;
            transform: translateY(-2px);
        }

        .dropdown-menu {
            border: none;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .dropdown-item {
            padding: 8px 20px;
            transition: all 0.2s;
        }

        .dropdown-item:hover {
            background-color: var(--secondary-color);
            color: white !important;
        }

        .container {
            max-width: 1200px;
            padding: 20px;
        }

        .presentacion {
            background-color: var(--secondary-color);
            color: white;
            padding: 40px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }

        .presentacion:hover {
            transform: translateY(-5px);
        }

        .boton-disp {
            width: 100%;
            margin: 10px 0;
            padding: 15px 20px;
            border: none;
            background-color: var(--primary-color);
            color: white;
            font-size: 1.1rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .boton-disp:hover {
            background-color: var(--dark-color);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .boton-disp i {
            transition: transform 0.3s ease;
        }

        .boton-disp.collapsed i {
            transform: rotate(-90deg);
        }

        #div_1,
        #div_2,
        #div_3,
        #div_4,
        #div_5 {
            padding: 25px;
            background-color: white;
            border-radius: 0 0 8px 8px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--secondary-color);
        }

        footer {
            background-color: var(--primary-color);
            color: white;
            padding: 50px 0 0;
            margin-top: 50px;
        }

        footer h5 {
            color: white;
            margin-bottom: 20px;
            font-weight: 700;
        }

        footer .nav-link {
            color: rgba(255, 255, 255, 0.7) !important;
            padding: 5px 0 !important;
        }

        footer .nav-link:hover {
            color: white !important;
            padding-left: 10px !important;
        }

        .border-top {
            border-color: rgba(255, 255, 255, 0.1) !important;
        }

        .social-icons a {
            color: white;
            font-size: 1.5rem;
            margin: 0 10px;
            transition: all 0.3s;
        }

        .social-icons a:hover {
            color: var(--secondary-color);
            transform: translateY(-3px);
        }

        .color-text {
            color: white;
        }

        .renglones {
            display: flex;
            flex-direction: column;
        }

        .margin-padding {
            margin: 0;
            padding: 0;
        }

        .centrar-imagen {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .centrar-imagen img {
            max-width: 600px;
            max-height: 600px;
        }

        .max-table {
            width: 100%;
            height: 100%;
        }

        @media (max-width: 768px) {
            .disposicion {
                flex-direction: column;
            }

            .navbar-brand {
                margin-bottom: 15px;
            }

            .presentacion {
                padding: 20px;
            }

            .centrar-imagen img {
                max-width: 400px;
                max-height: 400px;
            }

            .max-table {
                display: flex;
                justify-content: center;
                align-items: center;
                max-width: 100%;

            }
        }

        h1,
        h2,
        h3 {
            color: #2c3e50;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table,
        th,
        td {
            border: 1px solid #ddd;
        }

        th,
        td {
            padding: 12px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        figure {
            margin: 20px 0;
            text-align: center;
        }

        figcaption {
            font-style: italic;
            margin-top: 10px;
        }

        .highlight {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #4285f4;
            margin: 20px 0;
        }

        .paginacion {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .btn-paginacion {
            padding: 10px 25px;
            background-color: #2c3e50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
        }

        .btn-paginacion:hover {
            background-color: #3498db;
            text-decoration: none;
        }

        .btn-paginacion:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
            text-decoration: none;
        }
    </style>
</head>

<body>
    <div id="navbar-container"></div>


    <div class="container">
        <div class="presentacion">
            <h2>1.3 El problema de la busqueda</h2>
        </div>

        <div class="section">
            <p>La búsqueda en algoritmia se entiende como el proceso de localizar un elemento específico dentro de una
               estructura de datos, como listas, arreglos, árboles o grafos. Este problema es considerado uno de los más
               importantes en informática, dado que gran parte de los programas y sistemas requieren encontrar información
               de manera rápida y eficiente (Cormen, Leiserson, Rivest, y Stein, 2022).</p>

            <p>La búsqueda secuencial o lineal consiste en recorrer cada elemento de la estructura hasta encontrar el valor
               buscado o concluir que no existe. Su principal ventaja es la simplicidad y que no exige que los datos estén
               ordenados, aunque su desventaja es que presenta un costo de tiempo proporcional al tamaño de la entrada,
               con una complejidad de de O(n) (Cormen et al., 2022).</p>

            <p>La búsqueda binaria, en contraste, requiere que los datos estén previamente ordenados. Este algoritmo divide 
               repetidamente la lista en mitades, descartando la parte en la que el elemento no puede encontrarse. Su 
               eficiencia mejora notablemente, alcanzando una complejidad de O(logn), aunque su limitante es la necesidad
               del ordenamiento inicial (Knuth, 1998).</p>

            <p>Existen además métodos de búsqueda más avanzados, como en árboles de búsqueda, que permiten
               operaciones rápidas de búsqueda, inserción y eliminación, o en tablas hash, que logran tiempos promedio cercanos a 
               O(1) si el manejo de colisiones es eficiente (Sedgewick y Wayne, 2011).</p> 
          
            <p>El diseño de algoritmos de búsqueda eficientes es fundamental porque impacta directamente en el rendimiento de
               sistemas operativos, bases de datos, motores de búsqueda y aplicaciones de inteligencia artificial. De este modo,
               el estudio de las técnicas de búsqueda constituye un eje central dentro de la algoritmia (Cormen et al., 2022).</p>           
        </div>

        <div class="section" id="metodos-asignacion">
            <h4>1.3.1 Búsqueda secuencial</h4>

            <p>La búsqueda secuencial, también conocida como búsqueda lineal, es uno de los algoritmos más simples y fundamentales
               para localizar un elemento dentro de una estructura de datos. Consiste en recorrer de manera ordenada todos los elementos
               de la lista o arreglo, comparando cada uno con el valor buscado, hasta encontrarlo o concluir que no se encuentra en la
               colección (Cormen, Leiserson, Rivest, y Stein, 2022).</p>

           <p>Su principal ventaja radica en que puede aplicarse sobre cualquier tipo de estructura de datos, ya sea ordenada o no, lo que
              la hace universal y sencilla de implementar. Sin embargo, presenta la desventaja de ser poco eficiente en conjuntos grandes de datos,
              ya que en el peor de los casos requiere revisar todos los elementos, alcanzando una complejidad temporal de O(n) (Knuth, 1998).</p>
               
            <p>La búsqueda secuencial resulta adecuada cuando se trabaja con listas pequeñas o cuando no se justifica el costo adicional de
               ordenar los datos o implementar algoritmos más complejos. Además, sigue siendo útil como referencia en la enseñanza de algoritmos
               por su claridad y facilidad de comprensión (Sedgewick y Wayne, 2011).</p>   
        </div>

        <div class="section" id="asignacion-contigua">
            <h4>1.3.2 Búsqueda binaria</h4>
      
            <p>La búsqueda binaria es un algoritmo eficiente que permite localizar un elemento en una estructura de datos ordenada. Su funcionamiento
               se basa en dividir repetidamente el conjunto a la mitad: se compara el valor buscado con el elemento central y, dependiendo del resultado,
               se descarta la mitad en la que no puede encontrarse. Este proceso se repite hasta localizar el valor o concluir que no está presente en 
               la colección.</p>

           <p>Una de sus ventajas más importantes es la reducción del número de comparaciones respecto a la búsqueda secuencial. En lugar de recorrer
              todos los elementos, el algoritmo disminuye exponencialmente el espacio de búsqueda, logrando una complejidad temporal de O(logn). No
              obstante, su principal desventaja es que exige que los datos estén previamente ordenados, lo cual puede incrementar el costo total en
              ciertos contextos.</p>
               
            <p>La búsqueda binaria es especialmente útil en aplicaciones que requieren consultas rápidas sobre grandes volúmenes de datos estáticos
               o poco cambiantes. Es ampliamente utilizada en el diseño de sistemas, en la optimización de búsquedas dentro de bases de datos y en la
               implementación de algoritmos avanzados, como los relacionados con árboles de búsqueda y estructuras indexadas.</p>  
        

            <p>La figura 9 muestra una clasificación de los algoritmos de búsqueda, destacando la búsqueda secuencial como la forma más básica de localizar
               un elemento en una estructura de datos. Su principal ventaja es que puede aplicarse sobre cualquier colección, ya que no requiere que los datos
               estén ordenados; sin embargo, presenta una gran desventaja en términos de eficiencia, pues al tener una complejidad lineal, resulta poco adecuada
               para conjuntos de gran tamaño (Cormen, Leiserson, Rivest, y Stein, 2022).</p>
            <br>
            <figure>

                <span>Figura 9. El problema de la búsqueda (Cormen, Leiserson, Rivest, y Stein, 2022).</span>
            </figure>
            <div class="centrar-imagen">
                <img src="images/figura9.png" alt="Figura_9" style="max-width: 500px; max-height: 500px;">
            </div>
   
        </div>   
 
            <div class="highlight">
                <p>En caso de requerir más información sobre el tema, se proporciona el siguiente material audiovisual.
                </p>
                <p>Reynoso L. (2020)<em>Búsqueda y Secuencia Binaria</em> <i></i>[Video] Universidad Nacional del Comahue. <a href="https://www.youtube.com/watch?v=B6o8dgLZbV0"
                        target="_blank">https://www.youtube.com/watch?v=B6o8dgLZbV0</a>
                </p>
            </div>
        <div class="section" id="asignacion-ligada">
            <h4>1.3.3 Búsqueda indexada</h4>

            <div class="quote">
                <p>La búsqueda indexada es un método que utiliza una estructura auxiliar de índices para localizar
                elementos dentro de grandes volúmenes de datos. A diferencia de la búsqueda secuencial o binaria,
                este enfoque crea un índice que actúa como una guía, permitiendo acceder más rápidamente a los
                registros deseados sin necesidad de recorrer toda la colección.</p>

               <p>El uso de índices presenta la ventaja de reducir de manera significativa el tiempo de búsqueda, ya que
                 posibilita saltar directamente a la posición aproximada donde se encuentra el dato. Esto es particularmente
                 eficiente en bases de datos, donde los índices funcionan de manera análoga a los de un libro: permiten localizar
                 información de forma inmediata a partir de una clave. Sin embargo, una de sus desventajas es que requiere
                 espacio adicional para almacenar los índices y tiempo de mantenimiento cuando se insertan, eliminan o modifican 
                 registros.</p>

                <p>La búsqueda indexada es ampliamente utilizada en sistemas de gestión de bases de datos (SGBD) y en estructuras 
                   complejas como árboles B y B+, ya que optimiza la recuperación de información en entornos con gran cantidad de 
                   datos. Su relevancia radica en que equilibra la eficiencia de acceso con la gestión de almacenamiento, siendo
                   un componente esencial en el diseño de sistemas de información modernos (Date, 2004).</p>     

                <p>La figura 10, representa el proceso de la búsqueda indexada, mostrando cómo un índice actúa como guía para acceder
                   a los registros de un conjunto de datos. En lugar de recorrer toda la colección, el índice permite localizar directamente
                   la posición del elemento buscado, optimizando así el tiempo de recuperación de información (Silberschatz, Korth, y Sudarshan, 2020).</p>

                            <br>
            <figure>

                <span>Figura 10. Búsqueda indexada (Silberschatz, Korth, y Sudarshan, 2020; Elmasri y Navathe, 2016; Date, 2004).</span>
            </figure>
            <div class="centrar-imagen">
                <img src="images/figura10.png" alt="Figura_10" style="max-width: 500px; max-height: 500px;">
            </div>

        </div>
</div>
       
        <div class="section" id="administracion-espacio">
            <h4>1.3.4 Comparación de órdenes de complejidad</h4>

            <p>El análisis de la complejidad algorítmica permite comparar distintos algoritmos de búsqueda con base en su
               eficiencia temporal y espacial. Este análisis se expresa comúnmente mediante la notación Big-O, la cual describe
               el comportamiento del tiempo de ejecución en el peor de los casos a medida que aumenta el tamaño de la 
               entrada (Cormen, Leiserson, Rivest, y Stein, 2022).</p>

            <p>En la búsqueda secuencial, la complejidad es O(n), ya que en el peor escenario es necesario recorrer todos los
               elementos de la colección. Esto significa que el tiempo de ejecución crece de manera proporcional al número de
               datos, siendo poco eficiente en grandes volúmenes de información (Knuth, 1998).</p>

            <p>En contraste, la búsqueda binaria alcanza una complejidad de O(logn), pues reduce a la mitad el espacio de búsqueda
               en cada iteración, resultando mucho más eficiente que la búsqueda secuencial, aunque requiere que los datos estén
               ordenados previamente. Por su parte, la búsqueda indexada puede considerarse cercana a O(1) en promedio, ya que el
               acceso mediante índices permite llegar directamente al registro deseado; no obstante, este método implica costos
               adicionales en espacio y mantenimiento del índice (Sedgewick y Wayne, 2011)..</p>

            <p>La comparación muestra que no existe un único algoritmo “mejor” para todos los contextos. La elección depende de las
               características de los datos y de los recursos disponibles: la búsqueda secuencial es útil en colecciones pequeñas y
               no ordenadas, la binaria resulta óptima en conjuntos ordenados y estáticos, mientras que la indexada es indispensable
               en sistemas de bases de datos donde la eficiencia en grandes volúmenes es crítica.</p>

           <figure>

                <span>Figura 11. Comparación de órdenes de complejidad en algoritmos de búsqueda. (Cormen, T. H., Leiserson, C. E., Rivest, R. L.,
                      y Stein, C. (2022); Knuth, D. E. (1998); Sedgewick, R., y Wayne, K. (2011); Silberschatz, A., Korth, H. F.,
                      y Sudarshan, S. (2020)).</span>
            </figure>
            <div class="centrar-imagen">
                <img src="images/figura11.png" alt="Figura_11" style="max-width: 500px; max-height: 500px;">
            </div>

         <div class="highlight">
            <h4>Resumen de la sección el problema de la búsqueda</h4>
            <ul>
                <li>La comparación de los algoritmos de búsqueda evidencia que la búsqueda secuencial es simple y flexible pero ineficiente en colecciones
                    extensas por su crecimiento lineal; la búsqueda binaria mejora notablemente la eficiencia al reducir el espacio de búsqueda en cada paso,
                    alcanzando un orden logarítmico pero exige datos previamente ordenados; y la búsqueda indexada resulta clave en sistemas modernos y bases
                    de datos al posibilitar accesos cercanos a tiempo constante, a costa de espacio y mantenimiento de los índices.</li>

                <li>No existe un algoritmo universalmente superior: la secuencial conviene en conjuntos pequeños y desordenados, la binaria en colecciones
                    estáticas y ordenadas, y la indexada cuando se gestionan grandes volúmenes y la latencia de consulta es crítica. Por ello, la elección
                    informada debe apoyarse en el análisis de complejidad, el patrón de operaciones (búsquedas vs. actualizaciones), y las restricciones de
                    memoria/tiempo del sistema, integrando criterios tanto teóricos como de ingeniería de datos.</li>    
                    
            </ul>
        </div>
  
  

        <p><strong>¿Que importancia tiene la exploración exhaustiva y vuelta atrás?</strong></p>


        <div class="paginacion">
            <a href="Cuestionario1_2.html" class="btn-paginacion">Anterior</a>
            <a href="Cuestionario1_3.html" class="btn-paginacion">Siguiente</a>
        </div>
    </div>
  </div>      

    <div id="footer-container"></div>


    <script>
        $(document).ready(function () {
            fetch('navbar.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('navbar-container').innerHTML = data;
                    initNavbarScripts(); // Si necesitas inicializar scripts del navbar
                });

            fetch('footer.html')
                .then(response => response.text())
                .then(data => {
                    document.getElementById('footer-container').innerHTML = data;
                });
        });
    </script>


</body>

</html>
